"""

- 연속된 자료구조

: 연속된 자료구조는 모든 원소를 단일 메모리 청크에 저장한다. 
안쪽 작은 사각형들은 각각의 원소가 저장된 메모리 공간을 의미한다.
만약 같은 타입의 원소들이 연속된 메모리 공간에 저장되어 있다면, 모든 원소는 같은 크기의 메모리를 사용하고 이는 
sizeof(type)으로 표시한다. 

: 첫번째 원소의 메모리 주소를 시작 주소라고 한다.
모든 원소가 같은 타입이라면 두 번째 원소의 위치는 BA + sizeof(type)이다.
그 다음 원소의 위치는 BA + 2 * sizeof(type)이다. 나머지 원소 위치도 이와 같은 방식으로 계산할 수 있다. 
즉, i번째 원소에 접근하려면 BA + i * sizeof(type) 수식을 사용한다. 

: 이런 자료 구조에서는 배열의 전체 크기에 상관없이 앞서 설명한 수식을 이용하여 모든 원소에 접근할 수 있다.
따라서 접근 시간은 항상 일정하다. 이러한 경우는 Big-O 표기법으로 O(1)로 표기한다. 


: 배열의 유형은 크게 정적 배열과 동적 배열로 나눌 수 있다. 
정적 배열은 선언된 블록이 끝나면 소멸되는 한편, 동적 배열은 프로그래머가 생성할 시점과 해제할 시점을 자유롭게 설정할 수 있다. 
이러한 배열은 C 언어에서 도입되었기 때문에, C 스타일 배열이라고도 한다. 

    - 정적 배열은 int arr[size]; 형태라고 선언한다. 
    - C에서 동적 배열은 int* arr = (int*)malloc(size * sizeof(int)); 형태로 선언한다.  
    - C++에서 동적 배열은 int* arr = new int[size]; 형태로 선언한다.
    
정적 배열은 스택 메모리 영역에 할당되기 때문에 함수를 벗어날 때 자동으로 해제한다.   
반면에 동적 배열은 힙 영역에 할당되며 사용자가 직접 해제하기 전까지 유지된다. 

: 배열 같은 연속된 자료구조는 각 원소는 서로 인접해 있기 때문에 하나의 원소에 접근할 때 
그 옆에 있는 원소 몇 개도 함께 캐시로 가져온다. 
그러므로 다시 주변 원소에 접근할 때에는 해당 원소를 캐시에서 가져오게 되며, 이 작업은 매우 빠르게 동작한다.

: 이러한 속성을 캐시 지역성이라고 한다. 어떤 연산의 점근적 시간 복잡도 계산에는 영향을 주지 않지만, 
실제 동작에서 배열처럼 연속된 원소에 매우 빠르게 접근할 수 있다는 점은 큰 장점이 된다.    
    
    
    
"""